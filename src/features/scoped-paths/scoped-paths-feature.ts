import z from 'zod'
import * as vscode from 'vscode'
import { pathToUri } from '../../utils/path-to-uri'
import { unique } from '../../utils/unique'
import { ScopedPathsConfig } from './scoped-paths-config'
import { createDebouncedFunction } from '../../utils/create-debounced-function'
import { CachedDirectoryReader } from '../../utils/cached-directory-reader'
import { generateExcludedPathsFromScopedAndExcludedPaths } from './toolkit/generate-excluded-paths-from-scoped-and-excluded-paths'
import { defaultCurrentScope, generateQuickScope, isQuickScope } from './common'
import { ScopedPathsWorkspaceState } from './scoped-paths-workspace-state'
import { ScopedPathsCache } from './scoped-paths-cache'
import { getTargetPathsForCommand } from './toolkit/get-target-paths-for-command'
import { getConfig, safeConfigInspect } from '../../config'
import { basename } from 'path'
import { DynamicScopeProvider } from './dynamic-scope-provider'
import { RegisterCommand } from '../../register-command'
import { createScopedUriToPath } from './toolkit/create-scoped-uri-to-path'
import { createDisposableInterval } from '../../utils/create-disposable-interval'
import { uriToPath } from '../../utils/uri-to-path'

/** Set in "files.exclude" to ensure that current excludes were generated by Streamline */
const SCOPED_PATHS_KEY = '__set_by_streamline__'

/** Safely save workspace folders snapshot while this cooldown is active */
const APPLY_WORKSPACE_FOLDERS_COOLDOWN_MS = 3000

/**
 * From VS Code documentation:
 * - "Note: it is not valid to call updateWorkspaceFolders() multiple times without waiting for the onDidChangeWorkspaceFolders() to fire."
 */
export function createScopedPathsFeature(input: {
  context: vscode.ExtensionContext
  registerCommand: RegisterCommand
  onChange: () => unknown
  dynamicScopeProviders: DynamicScopeProvider[]
}) {
  const { context, registerCommand, onChange, dynamicScopeProviders } = input

  // Quick Scope
  dynamicScopeProviders.push({
    name: 'Quick Scope',
    iconPath: new vscode.ThemeIcon('folder'),
    isScopeMatching: (scope) => isQuickScope(scope),
    getScopedAndExcludedPaths: ({ currentScope: scope }) => [scope.slice(1)],
    getScopes: () => getCurrentWorkspaceFoldersSnapshot().map(wf => generateQuickScope(wf.name)),
    subscribe: (callback) => {
      context.subscriptions.push(vscode.workspace.onDidChangeWorkspaceFolders(() => callback()))
    }
  })

  const textStatusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Right, 2)
  textStatusBarItem.name = 'Scoped Paths: Change Current Scope'
  textStatusBarItem.tooltip = 'Scoped Paths: Change Current Scope...'
  textStatusBarItem.command = 'streamline.scopedPaths.changeCurrentScope'
  context.subscriptions.push(textStatusBarItem)
  textStatusBarItem.show()

  const buttonStatusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Right, 1)
  buttonStatusBarItem.name = 'Scoped Paths: Scoped Paths: Toggle Current Scope'
  buttonStatusBarItem.tooltip = 'Toggle Current Scope'
  context.subscriptions.push(buttonStatusBarItem)
  buttonStatusBarItem.show()

  const config = new ScopedPathsConfig()
  const workspaceState = new ScopedPathsWorkspaceState(context.workspaceState)

  const cache = new ScopedPathsCache(config, workspaceState, dynamicScopeProviders, getCurrentWorkspaceFoldersSnapshot)
  config.onChange = workspaceState.onChange = () => {
    cache.update()
    onChange()
  }

  const directoryReader = new CachedDirectoryReader()

  const scheduleConfigLoad = createDebouncedFunction(async () => {
    if (!config.load()) return
    updateStatusBarItems()
    directoryReader.clearCache()
    await updateContextInBackground()
    await updateExcludesInBackground()
  }, 500)

  const scheduleHardRefresh = createDebouncedFunction(async () => {
    updateStatusBarItems()
    directoryReader.clearCache()
    await updateContextInBackground()
    await updateExcludesInBackground()
  }, 500)

  const scheduleSoftRefresh = createDebouncedFunction(async () => {
    updateStatusBarItems()
    await updateContextInBackground()
    await updateExcludesInBackground()
  }, 250)

  function isCurrentScopeEditable() {
    return dynamicScopeProviders.every(p => !p.isScopeMatching(workspaceState.getCurrentScope()))
  }

  /** Takes a snapshot of currently opened files and disables the Current Scope temporarily until certain conditions are met */
  async function enableQuickUnscope() {
    workspaceState.setQuickUnscopePathsSnapshot(getCurrentlyOpenedPaths())
    updateStatusBarItems()
    updateContextInBackground()
    await workspaceState.save()

    await vscode.commands.executeCommand('streamline.scopedPaths.disableScope')
  }

  /** Disables Quick Unscope and re-enables the Current Scope if necessary */
  async function disableQuickUnscope() {
    if (workspaceState.getQuickUnscopePathsSnapshot() === undefined) return

    workspaceState.setQuickUnscopePathsSnapshot(undefined)
    updateStatusBarItems()
    updateContextInBackground()
    await workspaceState.save()

    if (!workspaceState.getEnabled()) {
      await vscode.commands.executeCommand('streamline.scopedPaths.enableScope')
    }
  }

  /** Returns 'true' is excludes are currently set by the extension */
  function isScopedPathsEffectivelyEnabled() {
    const workspaceConfig = vscode.workspace.getConfiguration('files', null)
    const currentExcludes = workspaceConfig.get('exclude', undefined)
    return currentExcludes?.[SCOPED_PATHS_KEY] === false
  }

  /** Returns currently scoped workspace folders, but only ones that are valid in context of the current snapshot */
  function getScopedWorkspaceFolders(): vscode.WorkspaceFolder[] {
    const currentWorkspaceFoldersSnapshot = getCurrentWorkspaceFoldersSnapshot()
    const scopedWorkspaceFolderNames = cache.getCachedCurrentlyScopedWorkspaceFolderNames()
    const excludedWorkspaceFolderNames = cache.getCachedCurrentlyExcludedWorkspaceFolderNames()

    return scopedWorkspaceFolderNames.length > 0
      ? currentWorkspaceFoldersSnapshot.filter(wf => scopedWorkspaceFolderNames.includes(wf.name))
      : excludedWorkspaceFolderNames.length > 0
        ? currentWorkspaceFoldersSnapshot.filter(wf => !excludedWorkspaceFolderNames.includes(wf.name))
        : currentWorkspaceFoldersSnapshot // Avoid removing all workspace folders if none are scoped
  }

  /** Stores timestamp of latest workspace folders change by the extension, used for cooldown */
  let appliedWorkspaceFoldersAt = Date.now()

  /** Updates current workspace folders to match 'expected' list of workspace folders (depending on whether scope is enabled in state) - only if necessary */
  function applyWorkspaceFolders() {
    if (!vscode.workspace.workspaceFolders) return // Do nothing when no workspace is opened

    const currentWorkspaceFolders = [...vscode.workspace.workspaceFolders]
    const expectedWorkspaceFolders = workspaceState.getEnabled()
      ? getScopedWorkspaceFolders()
      : getCurrentWorkspaceFoldersSnapshot()

    const requiresUpdate = currentWorkspaceFolders.length !== expectedWorkspaceFolders.length
      || currentWorkspaceFolders.some(wf1 => expectedWorkspaceFolders.every(wf2 => wf1.uri.path !== wf2.uri.path))

    console.debug('[ScopedPaths] applyWorkspaceFolders()', {
      current: currentWorkspaceFolders.map(wf => wf.name),
      expected: expectedWorkspaceFolders.map(wf => wf.name),
      requiresUpdate,
    })

    if (requiresUpdate) {
      vscode.workspace.updateWorkspaceFolders(0, currentWorkspaceFolders.length, ...expectedWorkspaceFolders)
      appliedWorkspaceFoldersAt = Date.now()
      return true
    }

    return false
  }

  /** Updates "files.exclude" configuration based on the currently 'scoped paths' & 'excluded paths' */
  async function updateExcludesInBackground() {
    if (!vscode.workspace.workspaceFolders) return // Do nothing when no workspace is opened

    try {
      await saveCurrentWorkspaceFoldersSnapshot()

      const hasChanged = applyWorkspaceFolders()
      if (hasChanged) return // Retry automatically when onDidChangeWorkspaceFolders() triggers

      const workspaceConfig = vscode.workspace.getConfiguration('files', null)

      const scopedAndExcludedPaths = cache.getCachedCurrentlyScopedAndExcludedPaths()
      if (workspaceState.getEnabled() && scopedAndExcludedPaths.length > 0 /* avoid unnecessarily setting excludes when there is nothing to exclude */) {
        const excludedPaths = await generateExcludedPathsFromScopedAndExcludedPaths(
          scopedAndExcludedPaths,
          directoryReader,
          vscode.workspace.workspaceFolders.map(wf => wf.name),
        )

        const excludes = {
          // Special key to be able to detect that these excludes were indeed set by the extension
          [SCOPED_PATHS_KEY]: false,
          // These excludes are set by default in VS Code, so we want to keep them
          '**/.git': true,
          '**/.svn': true,
          '**/.hg': true,
          '**/CVS': true,
          '**/.DS_Store': true,
          '**/Thumbs.db': true,
          // Excludes generated by the extension
          ...Object.fromEntries(excludedPaths.map(excludedPath => [`${excludedPath}/**`, true]))
        }

        await workspaceConfig.update('exclude', excludes, vscode.ConfigurationTarget.Workspace)
      } else if (isScopedPathsEffectivelyEnabled()) {
        // Only remove current excludes when they're explicitly set by Streamline,
        // which prevents VS Code from creating ".vscode/settings.json" when it's not necessary
        await workspaceConfig.update('exclude', undefined, vscode.ConfigurationTarget.Workspace)
      }
    } catch (error) {
      console.warn('[ScopedPaths] Could not update workspace configuration', error)
    }
  }

  function updateStatusBarItems() {
    textStatusBarItem.text = workspaceState.getCurrentScope()

    buttonStatusBarItem.command = workspaceState.getEnabled() ? 'streamline.scopedPaths.disableScope' : 'streamline.scopedPaths.enableScope'
    buttonStatusBarItem.text = workspaceState.getEnabled()
      ? '$(pass-filled)'
      : workspaceState.getQuickUnscopeEnabled()
        ? '$(stop-circle)'
        : '$(circle-large-outline)'
  }

  /** Create / update snapshot of 'current' workspace folders to be able to restore from it when unscoped */
  async function saveCurrentWorkspaceFoldersSnapshot() {
    if (!vscode.workspace.workspaceFolders) return // Do nothing when no workspace is opened

    // if not already saved, avoid unnecessarily saving snapshot if not scoped or if there's only one workspace folder
    if (!getConfig().inspect('scopedPaths.workspaceFoldersSnapshot')?.workspaceValue) {
      if (!workspaceState.getEnabled() && !isScopedPathsEffectivelyEnabled()) return
      if (vscode.workspace.workspaceFolders.length <= 1) return
    }

    let currentWorkspaceFolders: vscode.WorkspaceFolder[]

    // Safe mode:
    // If currently scoped (effectively or in state) or in cooldown, allow to only add new workspace folders to the snapshot
    // This prevents extension from permanently losing workspace folders from the snapshot
    if ((Date.now() - appliedWorkspaceFoldersAt) < APPLY_WORKSPACE_FOLDERS_COOLDOWN_MS
      || isScopedPathsEffectivelyEnabled()
      || workspaceState.getEnabled()) {
      currentWorkspaceFolders = [...getCurrentWorkspaceFoldersSnapshot()]

      for (const workspaceFolder of vscode.workspace.workspaceFolders) {
        if (currentWorkspaceFolders.every(wf => wf.uri.path !== workspaceFolder.uri.path)) {
          currentWorkspaceFolders.push(workspaceFolder)
        }
      }
    } else { // Otherwise, reflect current workspace folder list (unsafe mode)
      currentWorkspaceFolders = [...vscode.workspace.workspaceFolders]
    }

    console.debug('[ScopedPaths] saveCurrentWorkspaceFoldersSnapshot()', { currentWorkspaceFolders: currentWorkspaceFolders.map(wf => wf.name) })

    await getConfig().update(
      'scopedPaths.workspaceFoldersSnapshot',
      currentWorkspaceFolders
        // Sort by index generated by VS Code...
        .sort((a, b) => a.index - b.index)
        // But real index is still gonna be inferred from the saved order
        .map((workspaceFolder) => {
          // Do not save name if it matches basename from the path
          const generatedName = basename(workspaceFolder.uri.path)
          if (generatedName === workspaceFolder.name) {
            return workspaceFolder.uri.path
          }

          // Save path and custom name
          return `${workspaceFolder.uri.path}:${workspaceFolder.name}`
        }),
      vscode.ConfigurationTarget.Workspace, // Only makes sense in context of Workspace configuration
    )
  }

  function getCurrentWorkspaceFoldersSnapshot(): vscode.WorkspaceFolder[] {
    const inspectedSerializedWorkspaceFolders = safeConfigInspect(getConfig(), 'scopedPaths.workspaceFoldersSnapshot', z.array(z.string()))
    if (!inspectedSerializedWorkspaceFolders?.workspaceValue) {
      return [...vscode.workspace.workspaceFolders ?? []]
    }

    return inspectedSerializedWorkspaceFolders.workspaceValue
      .map((serializedWorkspaceFolder, index) => {
        if (serializedWorkspaceFolder.includes(':')) {
          const [path, ...nameParts] = serializedWorkspaceFolder.split(':')
          return {
            index,
            uri: vscode.Uri.parse(path),
            name: nameParts.join(':'),
          }
        }

        return {
          index,
          uri: vscode.Uri.parse(serializedWorkspaceFolder),
          name: basename(serializedWorkspaceFolder),
        }
      })
  }

  async function updateContextInBackground() {
    try {
      await Promise.all([
        vscode.commands.executeCommand('setContext', 'streamline.scopedPaths.enabled', workspaceState.getEnabled()),
        vscode.commands.executeCommand('setContext', 'streamline.scopedPaths.scopedPaths', cache.getCachedContextScopedPaths()),
        vscode.commands.executeCommand('setContext', 'streamline.scopedPaths.excludedPaths', cache.getCachedContextExcludedPaths()),
        vscode.commands.executeCommand('setContext', 'streamline.scopedPaths.quickUnscopeEnabled', workspaceState.getQuickUnscopeEnabled()),
      ])
    } catch (error) {
      console.warn('[ScopedPaths] Could not update context', error)
    }
  }

  // Toggle current scope
  registerCommand('streamline.scopedPaths.toggleScope', async () => {
    if (workspaceState.getEnabled()) {
      await vscode.commands.executeCommand('streamline.scopedPaths.disableScope')
    } else {
      await vscode.commands.executeCommand('streamline.scopedPaths.enableScope')
    }
  })

  // Activate current scope
  registerCommand('streamline.scopedPaths.enableScope', async () => {
    workspaceState.setEnabled(true)

    updateStatusBarItems()
    updateContextInBackground()
    updateExcludesInBackground()
    await workspaceState.save()

    await disableQuickUnscope()
  })

  // Deactivate current scope
  registerCommand('streamline.scopedPaths.disableScope', async () => {
    workspaceState.setEnabled(false)

    updateStatusBarItems()
    updateContextInBackground()
    updateExcludesInBackground()
    await workspaceState.save()
  })

  // Create a Quick Scope from a selected path
  registerCommand('streamline.scopedPaths.quickScopeIntoPath', async (uri: vscode.Uri | undefined, selectedUris: vscode.Uri[] | undefined) => {
    const paths = getTargetPathsForCommand(uri, selectedUris)
    if (paths.length === 0) return
    if (paths.length > 1) {
      vscode.window.showWarningMessage('Only one path can be used for Quick Scope')
      return
    }

    workspaceState.setCurrentScope(generateQuickScope(paths[0]))
    workspaceState.setEnabled(true)

    updateStatusBarItems()
    updateContextInBackground()
    updateExcludesInBackground()
    await workspaceState.save()

    await disableQuickUnscope()
  })

  // Add path to the current scope
  registerCommand('streamline.scopedPaths.addPathToCurrentScope', async (uri: vscode.Uri | undefined, selectedUris: vscode.Uri[] | undefined) => {
    if (!isCurrentScopeEditable()) {
      vscode.window.showWarningMessage('Current scope is not editable')
      return
    }

    const scopedPathsToAdd = getTargetPathsForCommand(uri, selectedUris)
    if (scopedPathsToAdd.length === 0) return

    config.setScopesObject({
      ...config.getScopesObject(),
      [workspaceState.getCurrentScope()]: unique([
        ...config.getScopesObject()[workspaceState.getCurrentScope()] ?? [],
        ...scopedPathsToAdd,
      ])
    })

    updateContextInBackground()
    updateExcludesInBackground()
    config.saveInBackground()

    await disableQuickUnscope()
  })

  // Delete path from the current scope
  registerCommand('streamline.scopedPaths.deletePathFromCurrentScope', async (uri: vscode.Uri | undefined, selectedUris: vscode.Uri[] | undefined) => {
    if (!isCurrentScopeEditable()) {
      vscode.window.showWarningMessage('Current scope is not editable')
      return
    }

    const scopedPathsToDelete = new Set(getTargetPathsForCommand(uri, selectedUris))
    if (scopedPathsToDelete.size === 0) return

    config.setScopesObject({
      ...config.getScopesObject(),
      [workspaceState.getCurrentScope()]: config.getScopesObject()[workspaceState.getCurrentScope()].filter(path => !scopedPathsToDelete.has(path)),
    })

    updateContextInBackground()
    updateExcludesInBackground()
    config.saveInBackground()
  })

  // Exclude path from the current scope (not the same as deleting path from the current scope!)
  registerCommand('streamline.scopedPaths.excludePathFromCurrentScope', async (uri: vscode.Uri | undefined, selectedUris: vscode.Uri[] | undefined) => {
    if (!isCurrentScopeEditable()) {
      vscode.window.showWarningMessage('Current scope is not editable')
      return
    }

    const excludedPathsToAdd = getTargetPathsForCommand(uri, selectedUris).map(path => `!${path}`)
    if (excludedPathsToAdd.length === 0) return

    config.setScopesObject({
      ...config.getScopesObject(),
      [workspaceState.getCurrentScope()]: unique([
        ...config.getScopesObject()[workspaceState.getCurrentScope()] ?? [],
        ...excludedPathsToAdd,
      ])
    })

    updateContextInBackground()
    updateExcludesInBackground()
    config.saveInBackground()
  })

  // Include previously 'excluded path' (not the same as adding path to the current scope!)
  registerCommand('streamline.scopedPaths.includePathIntoCurrentScope', async (uri: vscode.Uri | undefined, selectedUris: vscode.Uri[] | undefined) => {
    if (!isCurrentScopeEditable()) {
      vscode.window.showWarningMessage('Current scope is not editable')
      return
    }

    const excludedPathsToDelete = new Set(getTargetPathsForCommand(uri, selectedUris).map(path => `!${path}`))
    if (excludedPathsToDelete.size === 0) return

    config.setScopesObject({
      ...config.getScopesObject(),
      [workspaceState.getCurrentScope()]: config.getScopesObject()[workspaceState.getCurrentScope()].filter(path => !excludedPathsToDelete.has(path)),
    })

    updateContextInBackground()
    updateExcludesInBackground()
    config.saveInBackground()
  })

  // Select current scope
  registerCommand('streamline.scopedPaths.changeCurrentScope', async () => {
    const addNewScopeItem = 'Add new scope'

    const scopeQuickPickItems: (vscode.QuickPickItem & { scope?: string })[] = []
    const addedScopesSet = new Set<string>()

    const renameThemeIcon = new vscode.ThemeIcon('edit')
    const clearThemeIcon = new vscode.ThemeIcon('clear-all')
    const deleteThemeIcon = new vscode.ThemeIcon('trash')

    function addScopeQuickPickItem(scope: string) {
      if (addedScopesSet.has(scope)) return
      addedScopesSet.add(scope)

      const dynamicScopeProvider = dynamicScopeProviders.find(p => p.isScopeMatching(scope))
      const iconPath = dynamicScopeProvider?.iconPath ?? new vscode.ThemeIcon('circle-large-outline')

      // TODO: the same code in cache, extract
      const pathsInScope = unique(
        dynamicScopeProvider
          ? dynamicScopeProvider.getScopedAndExcludedPaths({
            currentScope: scope,
            uriToPath: createScopedUriToPath(getCurrentWorkspaceFoldersSnapshot()),
          })
          : (config.getScopesObject()[scope] ?? [])
      )

      const includedWorkspaceFolderNames = unique(pathsInScope.filter(path => !path.startsWith('!')).map(path => path.split('/')[0]))
      const excludedWorkspaceFolderNames = unique(pathsInScope.filter(path => path.startsWith('!') && !path.includes('/')))

      const stats = includedWorkspaceFolderNames.length > 0 || excludedWorkspaceFolderNames.length > 0
        ? [
          ...includedWorkspaceFolderNames.map(workspaceFolderName => {
            if (pathsInScope.includes(workspaceFolderName)) {
              return workspaceFolderName
            }

            const pathsInWorkspaceFolder = pathsInScope.filter(path => path.startsWith(workspaceFolderName + '/'))
            return `${workspaceFolderName} (${pathsInWorkspaceFolder.length})`
          }),
          ...excludedWorkspaceFolderNames,
        ].join(', ')
        : 'empty'

      scopeQuickPickItems.push({
        label: scope,
        iconPath: scope === workspaceState.getCurrentScope() ? new vscode.ThemeIcon('pass-filled') : iconPath,
        description: stats,
        scope,
        ...!dynamicScopeProvider && {
          buttons: [
            { iconPath: renameThemeIcon, tooltip: 'Rename...' },
            { iconPath: clearThemeIcon, tooltip: 'Clear' },
            { iconPath: deleteThemeIcon, tooltip: 'Delete' },
          ]
        }
      })
    }

    // Edge case when all scopes are deleted
    if (!config.getScopesObject()[workspaceState.getCurrentScope()]) {
      addScopeQuickPickItem(workspaceState.getCurrentScope())
    }

    for (const scope of Object.keys(config.getScopesObject())) {
      addScopeQuickPickItem(scope)
    }

    scopeQuickPickItems.push({
      label: addNewScopeItem,
      iconPath: new vscode.ThemeIcon('add'),
      alwaysShow: true,
    })

    scopeQuickPickItems.push({
      label: 'Dynamic scopes',
      kind: vscode.QuickPickItemKind.Separator,
    })

    for (const dynamicScopeProvider of dynamicScopeProviders) {
      for (const scope of dynamicScopeProvider.getScopes()) {
        addScopeQuickPickItem(scope)
      }
    }

    const quickPick = vscode.window.createQuickPick<vscode.QuickPickItem & { scope?: string }>()
    quickPick.items = scopeQuickPickItems

    quickPick.onDidAccept(async () => {
      const [selected] = quickPick.selectedItems
      if (!selected) return quickPick.dispose()

      let selectedScope = selected.scope
      if (!selectedScope) {
        selectedScope = await vscode.window.showInputBox({ prompt: 'Enter the name of new scope' })
        if (!selectedScope) return quickPick.dispose()

        config.setScopesObject({
          ...config.getScopesObject(),
          [selectedScope]: [],
        })
      }

      workspaceState.setCurrentScope(selectedScope)

      if (!selected.scope) {
        vscode.window.showInformationMessage(`Switched to new "${selectedScope}" scope`)
      }

      updateStatusBarItems()
      updateExcludesInBackground()
      config.saveInBackground()
      await workspaceState.save()

      quickPick.dispose()

      await disableQuickUnscope()
    })

    quickPick.onDidTriggerItemButton(async ({ item, button }) => {
      if (!item.scope) return quickPick.dispose()

      if (button.iconPath === renameThemeIcon) {
        const newScope = await vscode.window.showInputBox({ value: item.scope })
        if (!newScope) return quickPick.dispose()

        if (config.getScopesObject()[newScope]) {
          vscode.window.showWarningMessage(`Scope "${newScope}" already exists`)
          return
        }

        if (workspaceState.getCurrentScope() === item.scope) {
          workspaceState.setCurrentScope(newScope)
        }

        const newScopesObject = { ...config.getScopesObject() }
        delete newScopesObject[item.scope]
        newScopesObject[newScope] = config.getScopesObject()[item.scope]
        config.setScopesObject(newScopesObject)

        vscode.window.showInformationMessage(`Scope "${item.scope}" has been renamed to "${newScope}"`)
      }

      if (button.iconPath === clearThemeIcon) {
        config.setScopesObject({
          ...config.getScopesObject(),
          [item.scope]: [],
        })

        vscode.window.showInformationMessage(`Scope "${item.scope}" has been cleared`)
      }

      if (button.iconPath === deleteThemeIcon) {
        if (workspaceState.getCurrentScope() === item.scope) {
          workspaceState.setCurrentScope(defaultCurrentScope)
        }

        const scopesObject = { ...config.getScopesObject() }
        delete scopesObject[item.scope]
        config.setScopesObject(scopesObject)

        vscode.window.showInformationMessage(`Scope "${item.scope}" has been deleted`)
      }

      updateStatusBarItems()
      updateExcludesInBackground()
      config.saveInBackground()
      await workspaceState.save()

      quickPick.dispose()

      await vscode.commands.executeCommand('streamline.scopedPaths.changeCurrentScope')
    })

    quickPick.onDidHide(() => quickPick.dispose())
    quickPick.show()
  })

  // Clear all files in current scope
  registerCommand('streamline.scopedPaths.clearCurrentScope', async () => {
    if (!isCurrentScopeEditable()) {
      vscode.window.showWarningMessage('Current scope is not editable')
      return
    }

    config.setScopesObject({ ...config.getScopesObject(), [workspaceState.getCurrentScope()]: [] })

    updateContextInBackground()
    updateExcludesInBackground()
    config.saveInBackground()
  })

  // Temporarily disable Current Scope until certain conditions are met (e.g. unscoped file is opened or path was added to the scope)
  registerCommand('streamline.scopedPaths.enableQuickUnscope', async () => {
    await enableQuickUnscope()
  })

  // Disables Quick Unscope, a hidden command that is used to show different Scope icon in status bar and editor view
  registerCommand('streamline.scopedPaths.disableQuickUnscope', async () => {
    await disableQuickUnscope()
  })

  context.subscriptions.push(
    vscode.workspace.onDidChangeConfiguration((event) => {
      if (event.affectsConfiguration('streamline.scopedPaths')) {
        if (!config.isSavingInBackground) {
          scheduleConfigLoad()
        }
      }
    }),
    // Clear cache and re-generate excludes when files are created or renamed
    vscode.workspace.onDidCreateFiles(() => scheduleHardRefresh()),
    vscode.workspace.onDidRenameFiles(() => scheduleHardRefresh()),
    // Clear cache and re-generate excludes when workspace folders are added, renamed or deleted
    vscode.workspace.onDidChangeWorkspaceFolders(async () => {
      await saveCurrentWorkspaceFoldersSnapshot()
      scheduleHardRefresh()
    }),
    // 
    vscode.window.onDidChangeVisibleTextEditors(async () => {
      const quickUnscopePathsSnapshot = workspaceState.getQuickUnscopePathsSnapshot()
      if (quickUnscopePathsSnapshot === undefined) return

      const newPaths = getCurrentlyOpenedPaths().filter(path => !quickUnscopePathsSnapshot.includes(path))

      const scopedPaths = cache.getCachedCurrentlyScopedPaths()
      const excludedPaths = cache.getCachedCurrentlyExcludedPaths()

      const newScopedPaths = newPaths
        .filter(path => scopedPaths.some(scopedPath => scopedPath === path || path.startsWith(scopedPath + '/')))
        .filter(path => excludedPaths.every(excludedPath => excludedPath !== path && !path.startsWith(excludedPath + '/')))

      const newUnscopedPaths = newPaths.filter(path => !newScopedPaths.includes(path))
      if (newUnscopedPaths.length > 0) {
        await disableQuickUnscope()
      }
    }),
  )

  updateStatusBarItems()
  updateContextInBackground()
  updateExcludesInBackground()

  for (const dynamicScopeProvider of dynamicScopeProviders) {
    if (dynamicScopeProvider.subscribe) {
      dynamicScopeProvider.subscribe(() => {
        cache.update()
        scheduleSoftRefresh()
      })
    }
  }

  // Due to some bug, context is not properly updated when workspace folders are modified
  // Which can cause current scope status to be incorrect in Explorer view title icons
  // This is a workaround to ensure that context is updated eventually
  // Only suitable for lightweight operations
  context.subscriptions.push(
    createDisposableInterval(() => {
      updateStatusBarItems()
      updateContextInBackground()
    }, 1000)
  )

  return {
    isScopeEnabled() {
      return workspaceState.getEnabled()
    },
    getCurrentScope() {
      return workspaceState.getCurrentScope()
    },
    isPathCurrentlyScoped(path: string) {
      return cache.getCachedCurrentlyScopedPathsSet().has(path)
    },
    isPathCurrentlyExcluded(path: string) {
      return cache.getCachedCurrentlyExcludedPathsSet().has(path)
    },
    isParentOfCurrentlyScopedAndExcludedPaths(path: string) {
      return cache.getCachedParentsOfCurrentlyScopedAndExcludedPathsSet().has(path)
    },
  }
}

function getCurrentlyOpenedPaths(): string[] {
  return vscode.window.tabGroups.all
    .flatMap(tabGroup => tabGroup.tabs)
    .map(tab => tab.input)
    .map(input => input && typeof input === 'object' && 'uri' in input ? input.uri as vscode.Uri : undefined)
    .filter(uri => uri !== undefined)
    .map(uri => uriToPath(uri))
    .filter(path => path !== undefined)
}
